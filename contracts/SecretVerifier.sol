// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

// This interface matches the generated UltraVerifier from Noir
interface IUltraVerifier {
    function verify(bytes calldata _proof, bytes32[] calldata _publicInputs) external view returns (bool);
}

/**
 * @title SecretVerifier
 * @notice ZK proof verifier for secret commitments on Arc testnet
 * @dev Proves knowledge of a secret without revealing it
 */
contract SecretVerifier {
    IUltraVerifier public immutable verifier;

    // Track which commitments have been successfully verified
    mapping(bytes32 => bool) public verifiedCommitments;

    // Track who verified each commitment
    mapping(bytes32 => address) public commitmentProver;

    // Track verification count per address
    mapping(address => uint256) public verificationCount;

    event ProofVerified(
        bytes32 indexed commitment,
        address indexed prover,
        uint256 timestamp
    );

    constructor(address _verifier) {
        require(_verifier != address(0), "Invalid verifier address");
        verifier = IUltraVerifier(_verifier);
    }

    /**
     * @notice Verify a ZK proof that proves knowledge of a secret
     * @param proof The ZK proof bytes generated by Noir
     * @param commitment The public commitment (hash) being proven
     */
    function verifySecret(bytes calldata proof, bytes32 commitment) external {
        require(commitment != bytes32(0), "Invalid commitment");
        require(!verifiedCommitments[commitment], "Already verified");

        // Prepare public inputs for the verifier
        bytes32[] memory publicInputs = new bytes32[](1);
        publicInputs[0] = commitment;

        // Verify the proof
        require(verifier.verify(proof, publicInputs), "Invalid proof");

        // Record the verification
        verifiedCommitments[commitment] = true;
        commitmentProver[commitment] = msg.sender;
        verificationCount[msg.sender]++;

        emit ProofVerified(commitment, msg.sender, block.timestamp);
    }

    /**
     * @notice Check if a commitment has been verified
     * @param commitment The commitment to check
     * @return bool True if verified, false otherwise
     */
    function isVerified(bytes32 commitment) external view returns (bool) {
        return verifiedCommitments[commitment];
    }

    /**
     * @notice Get the address that verified a commitment
     * @param commitment The commitment to query
     * @return address The address that verified this commitment
     */
    function getProver(bytes32 commitment) external view returns (address) {
        return commitmentProver[commitment];
    }

    /**
     * @notice Get total verifications by an address
     * @param prover The address to query
     * @return uint256 Number of successful verifications
     */
    function getVerificationCount(address prover) external view returns (uint256) {
        return verificationCount[prover];
    }
}
